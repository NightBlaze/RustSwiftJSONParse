// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: big_json.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct BigJson {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: [Result] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Result {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var status: String {
    get {return _storage._status}
    set {_uniqueStorage()._status = newValue}
  }

  var name: Name {
    get {return _storage._name ?? Name()}
    set {_uniqueStorage()._name = newValue}
  }
  /// Returns true if `name` has been explicitly set.
  var hasName: Bool {return _storage._name != nil}
  /// Clears the value of `name`. Subsequent reads from it will return its default value.
  mutating func clearName() {_uniqueStorage()._name = nil}

  var username: String {
    get {return _storage._username}
    set {_uniqueStorage()._username = newValue}
  }

  var password: String {
    get {return _storage._password}
    set {_uniqueStorage()._password = newValue}
  }

  var phoneNumber: String {
    get {return _storage._phoneNumber ?? String()}
    set {_uniqueStorage()._phoneNumber = newValue}
  }
  /// Returns true if `phoneNumber` has been explicitly set.
  var hasPhoneNumber: Bool {return _storage._phoneNumber != nil}
  /// Clears the value of `phoneNumber`. Subsequent reads from it will return its default value.
  mutating func clearPhoneNumber() {_uniqueStorage()._phoneNumber = nil}

  var emails: [String] {
    get {return _storage._emails}
    set {_uniqueStorage()._emails = newValue}
  }

  var location: Location {
    get {return _storage._location ?? Location()}
    set {_uniqueStorage()._location = newValue}
  }
  /// Returns true if `location` has been explicitly set.
  var hasLocation: Bool {return _storage._location != nil}
  /// Clears the value of `location`. Subsequent reads from it will return its default value.
  mutating func clearLocation() {_uniqueStorage()._location = nil}

  var website: String {
    get {return _storage._website}
    set {_uniqueStorage()._website = newValue}
  }

  var domain: String {
    get {return _storage._domain}
    set {_uniqueStorage()._domain = newValue}
  }

  var job: Job {
    get {return _storage._job ?? Job()}
    set {_uniqueStorage()._job = newValue}
  }
  /// Returns true if `job` has been explicitly set.
  var hasJob: Bool {return _storage._job != nil}
  /// Clears the value of `job`. Subsequent reads from it will return its default value.
  mutating func clearJob() {_uniqueStorage()._job = nil}

  var creditCard: CreditCard {
    get {return _storage._creditCard ?? CreditCard()}
    set {_uniqueStorage()._creditCard = newValue}
  }
  /// Returns true if `creditCard` has been explicitly set.
  var hasCreditCard: Bool {return _storage._creditCard != nil}
  /// Clears the value of `creditCard`. Subsequent reads from it will return its default value.
  mutating func clearCreditCard() {_uniqueStorage()._creditCard = nil}

  var uuid: String {
    get {return _storage._uuid}
    set {_uniqueStorage()._uuid = newValue}
  }

  var objectID: String {
    get {return _storage._objectID}
    set {_uniqueStorage()._objectID = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Name {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var first: String = String()

  var middle: String = String()

  var last: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Location {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var street: String = String()

  var city: String = String()

  var state: String = String()

  var country: String = String()

  var zip: String = String()

  var coordinates: Coordinates {
    get {return _coordinates ?? Coordinates()}
    set {_coordinates = newValue}
  }
  /// Returns true if `coordinates` has been explicitly set.
  var hasCoordinates: Bool {return self._coordinates != nil}
  /// Clears the value of `coordinates`. Subsequent reads from it will return its default value.
  mutating func clearCoordinates() {self._coordinates = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _coordinates: Coordinates? = nil
}

struct Coordinates {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var latitude: Double = 0

  var longitude: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Job {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var title: String = String()

  var descriptor: String = String()

  var area: String = String()

  var type: String = String()

  var company: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreditCard {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var number: String = String()

  var cvv: String = String()

  var issuer: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension BigJson: @unchecked Sendable {}
extension Result: @unchecked Sendable {}
extension Name: @unchecked Sendable {}
extension Location: @unchecked Sendable {}
extension Coordinates: @unchecked Sendable {}
extension Job: @unchecked Sendable {}
extension CreditCard: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension BigJson: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BigJson"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BigJson, rhs: BigJson) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Result"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "name"),
    3: .same(proto: "username"),
    4: .same(proto: "password"),
    5: .same(proto: "phoneNumber"),
    6: .same(proto: "emails"),
    7: .same(proto: "location"),
    8: .same(proto: "website"),
    9: .same(proto: "domain"),
    10: .same(proto: "job"),
    11: .same(proto: "creditCard"),
    12: .same(proto: "uuid"),
    13: .same(proto: "objectId"),
  ]

  fileprivate class _StorageClass {
    var _status: String = String()
    var _name: Name? = nil
    var _username: String = String()
    var _password: String = String()
    var _phoneNumber: String? = nil
    var _emails: [String] = []
    var _location: Location? = nil
    var _website: String = String()
    var _domain: String = String()
    var _job: Job? = nil
    var _creditCard: CreditCard? = nil
    var _uuid: String = String()
    var _objectID: String = String()

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _status = source._status
      _name = source._name
      _username = source._username
      _password = source._password
      _phoneNumber = source._phoneNumber
      _emails = source._emails
      _location = source._location
      _website = source._website
      _domain = source._domain
      _job = source._job
      _creditCard = source._creditCard
      _uuid = source._uuid
      _objectID = source._objectID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularStringField(value: &_storage._status) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._name) }()
        case 3: try { try decoder.decodeSingularStringField(value: &_storage._username) }()
        case 4: try { try decoder.decodeSingularStringField(value: &_storage._password) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._phoneNumber) }()
        case 6: try { try decoder.decodeRepeatedStringField(value: &_storage._emails) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._location) }()
        case 8: try { try decoder.decodeSingularStringField(value: &_storage._website) }()
        case 9: try { try decoder.decodeSingularStringField(value: &_storage._domain) }()
        case 10: try { try decoder.decodeSingularMessageField(value: &_storage._job) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._creditCard) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._uuid) }()
        case 13: try { try decoder.decodeSingularStringField(value: &_storage._objectID) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if !_storage._status.isEmpty {
        try visitor.visitSingularStringField(value: _storage._status, fieldNumber: 1)
      }
      try { if let v = _storage._name {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      if !_storage._username.isEmpty {
        try visitor.visitSingularStringField(value: _storage._username, fieldNumber: 3)
      }
      if !_storage._password.isEmpty {
        try visitor.visitSingularStringField(value: _storage._password, fieldNumber: 4)
      }
      try { if let v = _storage._phoneNumber {
        try visitor.visitSingularStringField(value: v, fieldNumber: 5)
      } }()
      if !_storage._emails.isEmpty {
        try visitor.visitRepeatedStringField(value: _storage._emails, fieldNumber: 6)
      }
      try { if let v = _storage._location {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._website.isEmpty {
        try visitor.visitSingularStringField(value: _storage._website, fieldNumber: 8)
      }
      if !_storage._domain.isEmpty {
        try visitor.visitSingularStringField(value: _storage._domain, fieldNumber: 9)
      }
      try { if let v = _storage._job {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._creditCard {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      if !_storage._uuid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uuid, fieldNumber: 12)
      }
      if !_storage._objectID.isEmpty {
        try visitor.visitSingularStringField(value: _storage._objectID, fieldNumber: 13)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Result, rhs: Result) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._status != rhs_storage._status {return false}
        if _storage._name != rhs_storage._name {return false}
        if _storage._username != rhs_storage._username {return false}
        if _storage._password != rhs_storage._password {return false}
        if _storage._phoneNumber != rhs_storage._phoneNumber {return false}
        if _storage._emails != rhs_storage._emails {return false}
        if _storage._location != rhs_storage._location {return false}
        if _storage._website != rhs_storage._website {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._job != rhs_storage._job {return false}
        if _storage._creditCard != rhs_storage._creditCard {return false}
        if _storage._uuid != rhs_storage._uuid {return false}
        if _storage._objectID != rhs_storage._objectID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Name: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Name"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "first"),
    2: .same(proto: "middle"),
    3: .same(proto: "last"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.first) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.middle) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.last) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.first.isEmpty {
      try visitor.visitSingularStringField(value: self.first, fieldNumber: 1)
    }
    if !self.middle.isEmpty {
      try visitor.visitSingularStringField(value: self.middle, fieldNumber: 2)
    }
    if !self.last.isEmpty {
      try visitor.visitSingularStringField(value: self.last, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Name, rhs: Name) -> Bool {
    if lhs.first != rhs.first {return false}
    if lhs.middle != rhs.middle {return false}
    if lhs.last != rhs.last {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Location: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Location"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "street"),
    2: .same(proto: "city"),
    3: .same(proto: "state"),
    4: .same(proto: "country"),
    5: .same(proto: "zip"),
    6: .same(proto: "coordinates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.street) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.city) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.state) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.country) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.zip) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._coordinates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.street.isEmpty {
      try visitor.visitSingularStringField(value: self.street, fieldNumber: 1)
    }
    if !self.city.isEmpty {
      try visitor.visitSingularStringField(value: self.city, fieldNumber: 2)
    }
    if !self.state.isEmpty {
      try visitor.visitSingularStringField(value: self.state, fieldNumber: 3)
    }
    if !self.country.isEmpty {
      try visitor.visitSingularStringField(value: self.country, fieldNumber: 4)
    }
    if !self.zip.isEmpty {
      try visitor.visitSingularStringField(value: self.zip, fieldNumber: 5)
    }
    try { if let v = self._coordinates {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Location, rhs: Location) -> Bool {
    if lhs.street != rhs.street {return false}
    if lhs.city != rhs.city {return false}
    if lhs.state != rhs.state {return false}
    if lhs.country != rhs.country {return false}
    if lhs.zip != rhs.zip {return false}
    if lhs._coordinates != rhs._coordinates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Coordinates: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Coordinates"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "latitude"),
    2: .same(proto: "longitude"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.latitude) }()
      case 2: try { try decoder.decodeSingularDoubleField(value: &self.longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.latitude != 0 {
      try visitor.visitSingularDoubleField(value: self.latitude, fieldNumber: 1)
    }
    if self.longitude != 0 {
      try visitor.visitSingularDoubleField(value: self.longitude, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Coordinates, rhs: Coordinates) -> Bool {
    if lhs.latitude != rhs.latitude {return false}
    if lhs.longitude != rhs.longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Job: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Job"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "descriptor"),
    3: .same(proto: "area"),
    4: .same(proto: "type"),
    5: .same(proto: "company"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.descriptor) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.area) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.type) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.company) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.descriptor.isEmpty {
      try visitor.visitSingularStringField(value: self.descriptor, fieldNumber: 2)
    }
    if !self.area.isEmpty {
      try visitor.visitSingularStringField(value: self.area, fieldNumber: 3)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 4)
    }
    if !self.company.isEmpty {
      try visitor.visitSingularStringField(value: self.company, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Job, rhs: Job) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.descriptor != rhs.descriptor {return false}
    if lhs.area != rhs.area {return false}
    if lhs.type != rhs.type {return false}
    if lhs.company != rhs.company {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreditCard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreditCard"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "number"),
    2: .same(proto: "cvv"),
    3: .same(proto: "issuer"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.number) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.cvv) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.issuer) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.number.isEmpty {
      try visitor.visitSingularStringField(value: self.number, fieldNumber: 1)
    }
    if !self.cvv.isEmpty {
      try visitor.visitSingularStringField(value: self.cvv, fieldNumber: 2)
    }
    if !self.issuer.isEmpty {
      try visitor.visitSingularStringField(value: self.issuer, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreditCard, rhs: CreditCard) -> Bool {
    if lhs.number != rhs.number {return false}
    if lhs.cvv != rhs.cvv {return false}
    if lhs.issuer != rhs.issuer {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
